<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Morgan Gray">

<title>Model selection for abundance</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="model-selection_abundance_files/libs/clipboard/clipboard.min.js"></script>
<script src="model-selection_abundance_files/libs/quarto-html/quarto.js"></script>
<script src="model-selection_abundance_files/libs/quarto-html/popper.min.js"></script>
<script src="model-selection_abundance_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="model-selection_abundance_files/libs/quarto-html/anchor.min.js"></script>
<link href="model-selection_abundance_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="model-selection_abundance_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="model-selection_abundance_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="model-selection_abundance_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="model-selection_abundance_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods"><span class="header-section-number">2</span> Methods</a>
  <ul class="collapse">
  <li><a href="#initial-model-assessment" id="toc-initial-model-assessment" class="nav-link" data-scroll-target="#initial-model-assessment"><span class="header-section-number">2.1</span> Initial model assessment</a></li>
  <li><a href="#fixed-effects-selection" id="toc-fixed-effects-selection" class="nav-link" data-scroll-target="#fixed-effects-selection"><span class="header-section-number">2.2</span> Fixed effects selection</a></li>
  <li><a href="#random-effects-selection" id="toc-random-effects-selection" class="nav-link" data-scroll-target="#random-effects-selection"><span class="header-section-number">2.3</span> Random effects selection</a></li>
  <li><a href="#final-model-selection" id="toc-final-model-selection" class="nav-link" data-scroll-target="#final-model-selection"><span class="header-section-number">2.4</span> Final model selection</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results"><span class="header-section-number">3</span> Results</a>
  <ul class="collapse">
  <li><a href="#native-species" id="toc-native-species" class="nav-link" data-scroll-target="#native-species"><span class="header-section-number">3.1</span> Native species</a></li>
  <li><a href="#native-forb-species" id="toc-native-forb-species" class="nav-link" data-scroll-target="#native-forb-species"><span class="header-section-number">3.2</span> Native forb species</a></li>
  <li><a href="#non-native-species" id="toc-non-native-species" class="nav-link" data-scroll-target="#non-native-species"><span class="header-section-number">3.3</span> Non-native species</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">4</span> References</a>
  <ul class="collapse">
  <li><a href="#required-r-packages" id="toc-required-r-packages" class="nav-link" data-scroll-target="#required-r-packages"><span class="header-section-number">4.1</span> Required R packages:</a></li>
  </ul></li>
  <li><a href="#session-info" id="toc-session-info" class="nav-link" data-scroll-target="#session-info"><span class="header-section-number">5</span> Session info</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Model selection for abundance</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Morgan Gray </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>The objective of this analysis was to select the best-fitting generalized linear mixed model (GLMM) for percent cover abundance of native plant species. Abundance was measured as a continuous variable ranging from 0 to 1, representing the percent plot cover.</p>
</section>
<section id="methods" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Methods</h1>
<p>I used a systematic, three-stage approach to identify the optimal model structure for analyzing plant abundance data: initial model assessment, fixed effects selection, and random effects selection. Modular functions were developed to automate portions of the model selection process. All models were fit using restricted maximum likelihood (REML) via the <code>lmer</code> function from the <code>lme4</code> package (Bates et al.&nbsp;2015). Model comparison was primarily based on Akaike’s Information Criterion corrected for small sample size (AICc), calculated using the <code>MuMIn</code> package (Barton 2022). Models within a delta AICc of 6 were considered for further evaluation.Formal tests for uniform residual distribution (<code>testUniformity</code>), dispersion (<code>testDispersion</code>), and outlier detection (<code>testOutliers</code>) were performed using the <code>DHARMa</code> package (Hartig 2022). Diagnostic plots, including quantile-quantile plots (<code>DHARMa::plotQQunif</code>) and residual plots (<code>DHARMa::plotResiduals</code>), were visually inspected. Model singularity was assessed using the <code>performance</code> package (Lüdecke et al., 2021), specifically the <code>check_singularity</code> function. The <code>janitor</code> package (Firshman, 2023) was used for data cleaning and table formatting.</p>
<section id="initial-model-assessment" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="initial-model-assessment"><span class="header-section-number">2.1</span> Initial model assessment</h2>
<p>I began by fitting several initial models to explore the influence of response variable transformation. These models included a simple linear model with untransformed abundance, and linear mixed-effects models with log-transformed and square-root transformed abundance. For each transformation, four model structures were compared:</p>
<ul>
<li>A mixed-effects model with a random intercept for plot name (intercept-only): <code>lmer(abundance ~ 1 + (1 | plot_name))</code></li>
<li>A mixed-effects model with a random intercept and a random slope for treatment within plot name (without treatment as a fixed effect): <code>lmer(abundance ~ 1 + (1 + treatment | plot_name))</code></li>
<li>A mixed-effects model with treatment as a fixed effect and a random intercept for plot name: <code>lmer(abundance ~ treatment + (1 | plot_name))</code></li>
<li>A mixed-effects model with treatment as a fixed effect, and a random intercept and a random slope for treatment within plot name: <code>lmer(abundance ~ treatment + (1 + treatment | plot_name))</code></li>
</ul>
<p>AICc values were compared to identify the most promising transformation. QQ plots were used to assess residual normality for each transformation.</p>
</section>
<section id="fixed-effects-selection" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="fixed-effects-selection"><span class="header-section-number">2.2</span> Fixed effects selection</h2>
<p>Based on the best-performing transformation from the initial model assessment, I then fit a series of models with different combinations of fixed effects. Starting with the best performing initial model, I iteratively added or removed fixed effects: <code>plot_type</code>, <code>f_year</code>, <code>f_break</code>, <code>f_new</code>, <code>f_one_yr</code>, and <code>f_two_yr</code>.</p>
<p>An initial exploration was conducted using automated model dredging (via the <code>dredge</code> function from the <code>MuMIn</code> package), followed by manual model comparisons. The <code>dredge</code> function explores all possible predictor combinations and ranks them by AICc. While dredge results provided a comprehensive overview of potential variable influences and informed subsequent model selection, the dredge results themselves were not used to identify the final best-fit model.</p>
<p>I developed functions to streamline the fixed effect selection process. First, a function individually added each potential fixed effect to the best initial model and compared AICc values to identify the best single-term model. Next, a separate function added a second term to the best single-term model and compared AICc values to identify the best two-term model. Models with a delta AICc less than 6 were retained. Residual plots were examined for each model to assess model assumptions.</p>
</section>
<section id="random-effects-selection" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="random-effects-selection"><span class="header-section-number">2.3</span> Random effects selection</h2>
<p>After identifying a set of best-performing fixed effects models, I explored the inclusion of additional random effects. I tested the addition of random intercepts for other variables individually. I also tested the addition of random slopes for treatment within each predictor variable.</p>
<p>Model comparisons were again based on AICc, and models within a delta AICc of 6 were retained. Singularity checks were performed using the <code>lme4::check_singularity</code> function to ensure model convergence.</p>
</section>
<section id="final-model-selection" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="final-model-selection"><span class="header-section-number">2.4</span> Final model selection</h2>
<p>The final model was selected based on AICc, diagnostic plot review, and ecological interpretability. The model with the lowest AICc that met model assumptions and had a biologically plausible structure was chosen. Final model performance was assessed by examining residual plots, testing for uniform residual distribution using <code>testUniformity</code> (from <code>DHARMa</code>), and assessing for outliers. The rationale for each predictor’s inclusion in the final model was documented.</p>
</section>
</section>
<section id="results" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Results</h1>
<section id="native-species" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="native-species"><span class="header-section-number">3.1</span> Native species</h2>
<p>The log-transformed response with random slopes and intercepts for treatment by plot emerged as the best initial model based on AIC values and diagnostic plots.</p>
<p>The final selected model included log-transformed abundance as the response variable, treatment, year, and plot type as fixed effects, and random slopes and intercepts for treatment by plot. This model satisfied assumptions of uniform residual distribution and proper dispersion, showed no significant outliers, and maintained convergence without singularity issues.</p>
</section>
<section id="native-forb-species" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="native-forb-species"><span class="header-section-number">3.2</span> Native forb species</h2>
</section>
<section id="non-native-species" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="non-native-species"><span class="header-section-number">3.3</span> Non-native species</h2>
</section>
</section>
<section id="references" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> References</h1>
<ul>
<li>Barton, K. (2022). <em>MuMIn: Multi-Model Inference</em>. R package version 1.46.0.</li>
<li>Bates, D., Mächler, M., Bolker, B. M., &amp; Walker, S. C. (2015). Fitting Linear Mixed-Effects Models Using lme4. <em>Journal of Statistical Software</em>, <em>67</em>(1), 1–48.</li>
<li>Firshman, T. (2023). <em>janitor: Simple Data Frame Cleaning Functions</em>. R package version 2.2.0.</li>
<li>Hartig, F. (2022). <em>DHARMa: Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models</em>. R package version 0.4.6.</li>
<li>Lüdecke, D., Ben-Shachar, M., Patil, I., Waggoner, P., &amp; Makowski, D. (2021). performance: Assessing and Comparing Statistical Models. <em>Journal of Open Source Software</em>, <em>6</em>(60), 3139.</li>
</ul>
<section id="required-r-packages" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="required-r-packages"><span class="header-section-number">4.1</span> Required R packages:</h2>
<p>lme4: Model fitting</p>
<p>MuMIn: Model selection and multi-model inference</p>
<p>DHARMa: Model diagnostics and residual checks</p>
<p>dplyr: Data manipulation</p>
<p>janitor: Name cleaning</p>
<hr>
</section>
</section>
<section id="session-info" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Session info</h1>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>─ Session info ───────────────────────────────────────────────────────────────
 setting  value
 version  R version 4.4.0 (2024-04-24)
 os       macOS 15.2
 system   aarch64, darwin20
 ui       X11
 language (EN)
 collate  en_US.UTF-8
 ctype    en_US.UTF-8
 tz       America/Los_Angeles
 date     2025-01-28
 pandoc   3.2 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/aarch64/ (via rmarkdown)

─ Packages ───────────────────────────────────────────────────────────────────
 package      * version    date (UTC) lib source
 abind          1.4-8      2024-09-12 [1] CRAN (R 4.4.1)
 backports      1.5.0      2024-05-23 [1] CRAN (R 4.4.0)
 bit            4.0.5      2022-11-15 [1] CRAN (R 4.4.0)
 bit64          4.0.5      2020-08-30 [1] CRAN (R 4.4.0)
 boot           1.3-31     2024-08-28 [1] CRAN (R 4.4.1)
 broom          1.0.7      2024-09-26 [1] CRAN (R 4.4.1)
 broom.mixed  * 0.2.9.6    2024-10-15 [1] CRAN (R 4.4.1)
 car          * 3.1-3      2024-09-27 [1] CRAN (R 4.4.1)
 carData      * 3.0-5      2022-01-06 [1] CRAN (R 4.4.0)
 cellranger     1.1.0      2016-07-27 [1] CRAN (R 4.4.0)
 cli            3.6.3      2024-06-21 [1] CRAN (R 4.4.0)
 coda           0.19-4.1   2024-01-31 [1] CRAN (R 4.4.0)
 codetools      0.2-20     2024-03-31 [1] CRAN (R 4.4.0)
 crayon         1.5.3      2024-06-20 [1] CRAN (R 4.4.0)
 DHARMa       * 0.4.7      2024-10-18 [1] CRAN (R 4.4.1)
 digest         0.6.37     2024-08-19 [1] CRAN (R 4.4.1)
 dplyr        * 1.1.4      2023-11-17 [1] CRAN (R 4.4.0)
 emmeans        1.10.6     2024-12-12 [1] CRAN (R 4.4.1)
 estimability   1.5.1      2024-05-12 [1] CRAN (R 4.4.0)
 evaluate       1.0.3      2025-01-10 [1] CRAN (R 4.4.1)
 fansi          1.0.6      2023-12-08 [1] CRAN (R 4.4.0)
 fastmap        1.2.0      2024-05-15 [1] CRAN (R 4.4.0)
 forcats      * 1.0.0      2023-01-29 [1] CRAN (R 4.4.0)
 Formula        1.2-5      2023-02-24 [1] CRAN (R 4.4.0)
 furrr          0.3.1      2022-08-15 [1] CRAN (R 4.4.0)
 future         1.34.0     2024-07-29 [1] CRAN (R 4.4.0)
 generics       0.1.3      2022-07-05 [1] CRAN (R 4.4.0)
 glmmTMB      * 1.1.10     2024-09-26 [1] CRAN (R 4.4.1)
 globals        0.16.3     2024-03-08 [1] CRAN (R 4.4.0)
 glue         * 1.8.0      2024-09-30 [1] CRAN (R 4.4.1)
 here         * 1.0.1      2020-12-13 [1] CRAN (R 4.4.0)
 hms            1.1.3      2023-03-21 [1] CRAN (R 4.4.0)
 htmltools      0.5.8.1    2024-04-04 [1] CRAN (R 4.4.0)
 htmlwidgets    1.6.4      2023-12-06 [1] CRAN (R 4.4.0)
 insight        1.0.0      2024-11-26 [1] CRAN (R 4.4.1)
 jsonlite       1.8.8      2023-12-04 [1] CRAN (R 4.4.0)
 knitr          1.48       2024-07-07 [1] CRAN (R 4.4.0)
 lattice        0.22-6     2024-03-20 [1] CRAN (R 4.4.0)
 lifecycle      1.0.4      2023-11-07 [1] CRAN (R 4.4.0)
 listenv        0.9.1      2024-01-29 [1] CRAN (R 4.4.0)
 lme4         * 1.1-36     2025-01-11 [1] CRAN (R 4.4.1)
 magrittr       2.0.3      2022-03-30 [1] CRAN (R 4.4.0)
 MASS         * 7.3-64     2025-01-04 [1] CRAN (R 4.4.1)
 Matrix       * 1.7-0      2024-03-22 [1] CRAN (R 4.4.0)
 mgcv           1.9-1      2023-12-21 [1] CRAN (R 4.4.0)
 minqa          1.2.8      2024-08-17 [1] CRAN (R 4.4.0)
 MuMIn        * 1.48.4     2024-06-22 [1] CRAN (R 4.4.0)
 mvtnorm        1.3-2      2024-11-04 [1] CRAN (R 4.4.1)
 nlme           3.1-166    2024-08-14 [1] CRAN (R 4.4.0)
 nloptr         2.1.1      2024-06-25 [1] CRAN (R 4.4.0)
 numDeriv       2016.8-1.1 2019-06-06 [1] CRAN (R 4.4.0)
 parallelly     1.41.0     2024-12-18 [1] CRAN (R 4.4.1)
 performance  * 0.12.4     2024-10-18 [1] CRAN (R 4.4.1)
 pillar         1.9.0      2023-03-22 [1] CRAN (R 4.4.0)
 pkgconfig      2.0.3      2019-09-22 [1] CRAN (R 4.4.0)
 purrr          1.0.2      2023-08-10 [1] CRAN (R 4.4.0)
 R6             2.5.1      2021-08-19 [1] CRAN (R 4.4.0)
 rbibutils      2.3        2024-10-04 [1] CRAN (R 4.4.1)
 Rcpp           1.0.13     2024-07-17 [1] CRAN (R 4.4.0)
 Rdpack         2.6.2      2024-11-15 [1] CRAN (R 4.4.1)
 readr        * 2.1.5      2024-01-10 [1] CRAN (R 4.4.0)
 readxl       * 1.4.3      2023-07-06 [1] CRAN (R 4.4.0)
 reformulas     0.4.0      2024-11-03 [1] CRAN (R 4.4.1)
 rlang          1.1.4      2024-06-04 [1] CRAN (R 4.4.0)
 rmarkdown      2.28       2024-08-17 [1] CRAN (R 4.4.0)
 rprojroot      2.0.4      2023-11-05 [1] CRAN (R 4.4.0)
 rstudioapi     0.16.0     2024-03-24 [1] CRAN (R 4.4.0)
 sessioninfo  * 1.2.2      2021-12-06 [1] CRAN (R 4.4.0)
 tibble         3.2.1      2023-03-20 [1] CRAN (R 4.4.0)
 tidyr          1.3.1      2024-01-24 [1] CRAN (R 4.4.0)
 tidyselect     1.2.1      2024-03-11 [1] CRAN (R 4.4.0)
 TMB            1.9.16     2025-01-08 [1] CRAN (R 4.4.1)
 tzdb           0.4.0      2023-05-12 [1] CRAN (R 4.4.0)
 utf8           1.2.4      2023-10-22 [1] CRAN (R 4.4.0)
 vctrs          0.6.5      2023-12-01 [1] CRAN (R 4.4.0)
 vroom          1.6.5      2023-12-05 [1] CRAN (R 4.4.0)
 withr          3.0.2      2024-10-28 [1] CRAN (R 4.4.1)
 xfun           0.48       2024-10-03 [1] CRAN (R 4.4.1)
 xtable         1.8-4      2019-04-21 [1] CRAN (R 4.4.0)
 yaml           2.3.10     2024-07-26 [1] CRAN (R 4.4.0)

 [1] /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library

──────────────────────────────────────────────────────────────────────────────</code></pre>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>